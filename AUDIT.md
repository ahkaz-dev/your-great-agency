# Аудит проекта ai-browser-agent

**Дата:** 7 февраля 2026  
**Версии:** TypeScript 5.4+, Node ESM, Playwright ^1.58

---

## 1. Выполненные исправления

### 1.1 Импорты и ESM (TypeScript 5.4+ / Node ESM)

- **Проблема:** Импорты с расширением `.ts` не допускаются в TS 5.4 без `allowImportingTsExtensions`; при этом для Node ESM в скомпилированном коде нужны импорты с расширением `.js`.
- **Решение:** Все импорты переведены на расширение `.js` (путь к скомпилированным файлам). Сборка `npm run build` и запуск `node dist/index.js` работают корректно.
- **Dev-режим:** В проект добавлен `tsx`; скрипты `dev` и `agent` запускают `tsx src/index.ts`, так что после `npm install` можно вызывать `npm run dev "<task>"` без предварительной сборки (tsx разрешает импорты .js в исходных .ts файлах).

### 1.2 Тип контроллера браузера в `tools.ts`

- **Проблема:** В `createTools` передавался уже разрешённый контроллер, а тип указывал на `Promise`; внутри использовался двойной `await (await browser)`.
- **Решение:** Тип заменён на `BrowserController = Awaited<ReturnType<typeof createBrowserController>>`, вызовы упрощены до `browser.navigate()`, `browser.getSnapshot()` и т.д. Исправлена подпись возвращаемого значения при клике: возвращается `best.node.xpath`, а не `candidates[0].node.xpath`.

### 1.3 Типы памяти (`memory.ts` и `core.ts`)

- **Проблема:** В `MemoryItem` не было типов `'plan'` и `'status'`, при этом агент записывал их через `(e.type as any)`.
- **Решение:** В `MemoryItem.type` добавлены `'plan'` и `'status'`. В `core.ts` убрано приведение через `as any`, используется `MemoryItem['type']`.

---

## 2. Стабильность на новых версиях

### 2.1 TypeScript 5.4+

- Строгий режим включён, типы согласованы.
- Рекомендуется не использовать в импортах расширение `.ts`; для ESM оставить `.js` в путях импорта.

### 2.2 Node (в т.ч. v24)

- Проект в режиме ESM (`"type": "module"`). Запуск после сборки: `node dist/index.js`.
- В Node 18+ доступен встроенный `fetch`. При желании можно отказаться от `node-fetch` в `llm.ts` в пользу глобального `fetch` и удалить зависимость (проверить окружения без Node 18+).

### 2.3 Playwright ^1.58

- Используются `chromium.launch()`, `page.locator('xpath=...')`, `page.evaluate()` — актуальны для 1.x.
- При переходе на Playwright 2.x стоит проверить документацию по локаторам (приоритет у `getByRole`, `getByText` и т.д.; xpath по-прежнему поддерживается).

### 2.4 Зависимости

- `dotenv`: ^16.4.5 — актуально.
- `node-fetch`: ^3.3.2 (ESM) — при необходимости заменить на встроенный `fetch`.
- `playwright`: ^1.58.1 — перед мажорным обновлением просмотреть changelog и гайды по миграции.

---

## 3. Запуск и консоль

### Команды

```bash
# Сборка
npm run build

# Запуск (обязательно передать задачу)
node dist/index.js "Open google.com"

# Перед первым запуском установить браузеры Playwright
npx playwright install chromium
```

### Поведение при запуске

1. В консоль выводятся логи с префиксами `[INFO]`, `[ERROR]`, `[SUCCESS]`.
2. Инициализация: «Initializing browser...», «Launching browser...».
3. При отсутствии Chromium — сообщение с предложением выполнить `npx playwright install`.
4. Для работы агента нужны переменные окружения (например, `.env`): `LLM_API_KEY`, `LLM_BASE_URL` (опционально), `LLM_MODEL` (опционально). Без ключа для OpenAI запросы к LLM падают с ошибкой.

### Предупреждение npm

- Сообщение `Unknown env config "devdir"` связано с конфигурацией npm, а не с кодом проекта. На выполнение скриптов не влияет.

---

## 4. Рекомендации

1. **Dev-скрипт:** Добавить `tsx` в devDependencies и скрипт `"dev": "tsx src/index.ts"` для запуска без предварительной сборки (опционально).
2. **Playwright:** Выполнить `npx playwright install` (или `npx playwright install chromium`) после клонирования/установки зависимостей.
3. **Окружение:** Описать в README переменные `LLM_*` и пример `.env.example`.
4. **Тесты:** Запустить `npm run playwright` после установки браузеров и при необходимости обновить конфиг и тесты под текущие сценарии.

---

## 5. Аудит «агент не решает запрос» (по main-goal.md, README)

### 5.1 Выявленные причины

1. **Intent от LLM в неподходящем формате**  
   Модель иногда возвращала селекторный вид или примеры в `args.intent` (например `input[name=identifier]: your_email@example.com`). Матчинг в `selectors.ts` опирается на семантические слова (текст, aria, placeholder), из-за чего выбирался не тот элемент или матч был слабым.

2. **Слабые наблюдения в памяти**  
   После клика/ввода в память писались формулировки вроде «Clicked. New title?» без явного указания, какая страница открылась. Планировщик не видел однозначный результат последнего действия и хуже адаптировался.

3. **Рефлексия не учитывалась в следующем шаге**  
   После ошибки или рефлексии в историю добавлялось предложение (закрыть попап, скролл, другой клик), но в промпте следующего шага не было явной подсказки «учесть это предложение».

4. **Нет явного «где мы сейчас» в контексте плана**  
   В контекст не выносилась краткая сводка «текущая страница: title @ url» и напоминание выбирать intent по элементам этой страницы.

### 5.2 Внесённые исправления

- **selectors.ts:** добавлена `normalizeIntent(intent)`: из строки intent вырезаются селекторный синтаксис и примеры (например `your_email@...`, `input[name=...]`), для матчинга используются только семантические слова. В синонимы для матчинга добавлены русские варианты (поиск, войти, далее, добавить, корзина).
- **core.ts (системный промпт):** явно задано, что для click/type `args.intent` — только 1–3 семантических слова (например «Sign in», «Next», «email», «search»), без селекторов и примеров; intent нужно брать из текста/роли/placeholder элементов в сводке страницы.
- **core.ts (plan):** в контекст планировщика добавлены: краткая сводка «You are now on: "title" @ url»; подсказка при наличии в истории «Reflection»/«After failure» — учесть предложенное изменение на следующем шаге; `max_tokens` для плана увеличен до 620.
- **core.ts (execute):** после успешного click/type выполняется observe, в память пишется наблюдение вида «After click: page is now "title" @ url», чтобы следующий шаг опирался на фактический результат действия.

### 5.3 Соответствие main-goal.md

- **Без заготовок действий:** агент по-прежнему решает один шаг за раз из цели и текущей страницы; фиксированных сценариев нет.
- **Без преднаписанных селекторов:** селекторы строятся по семантике (текст, роль, placeholder); intent нормализуется, селекторный синтаксис из ответа LLM отбрасывается.
- **Обработка ошибок:** рефлексия после неудачного действия и подсказка в следующем промпте помогают агенту менять тактику (попап, скролл, другой клик).
- **Security layer:** подтверждение перед деструктивным действием (request_confirmation) реализовано.

---

## 6. Краткое резюме

- Сборка и тип-чек проходят. Запуск через `node dist/index.js "<task>"` или `npm run agent "<task>"` после `npm run build` и `npx playwright install chromium` работает.
- Код приведён в соответствие с TypeScript 5.4+ и Node ESM; типы контроллера и памяти исправлены.
- Для устойчивой работы агента по пользовательскому запросу: нормализация intent, чёткие правила для intent в промпте, богатые наблюдения в памяти, учёт рефлексии и явная сводка текущей страницы в контексте плана (см. раздел 5).
- Для полного цикла выполнения задачи нужны установленные браузеры Playwright и настроенный LLM (API key и при необходимости base URL и model).
